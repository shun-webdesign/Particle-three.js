{"version":3,"sources":["node_modules/three/examples/js/postprocessing/EffectComposer.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"EffectComposer.42b4ebcb.js","sourceRoot":"..","sourcesContent":["( function () {\n\n\tclass EffectComposer {\n\n\t\tconstructor( renderer, renderTarget ) {\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\tconst parameters = {\n\t\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\t\tformat: THREE.RGBAFormat\n\t\t\t\t};\n\t\t\t\tconst size = renderer.getSize( new THREE.Vector2() );\n\t\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\t\t\t\trenderTarget = new THREE.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t\t} else {\n\n\t\t\t\tthis._pixelRatio = 1;\n\t\t\t\tthis._width = renderTarget.width;\n\t\t\t\tthis._height = renderTarget.height;\n\n\t\t\t}\n\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\t\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\t\t\tthis.renderToScreen = true;\n\t\t\tthis.passes = []; // dependencies\n\n\t\t\tif ( THREE.CopyShader === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.CopyShader' );\n\n\t\t\t}\n\n\t\t\tif ( THREE.ShaderPass === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );\n\n\t\t\t}\n\n\t\t\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\t\t\tthis.clock = new THREE.Clock();\n\n\t\t}\n\n\t\tswapBuffers() {\n\n\t\t\tconst tmp = this.readBuffer;\n\t\t\tthis.readBuffer = this.writeBuffer;\n\t\t\tthis.writeBuffer = tmp;\n\n\t\t}\n\n\t\taddPass( pass ) {\n\n\t\t\tthis.passes.push( pass );\n\t\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tinsertPass( pass, index ) {\n\n\t\t\tthis.passes.splice( index, 0, pass );\n\t\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tremovePass( pass ) {\n\n\t\t\tconst index = this.passes.indexOf( pass );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tthis.passes.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLastEnabledPass( passIndex ) {\n\n\t\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\trender( deltaTime ) {\n\n\t\t\t// deltaTime value is in seconds\n\t\t\tif ( deltaTime === undefined ) {\n\n\t\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\t\t\tlet maskActive = false;\n\n\t\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\t\tconst pass = this.passes[ i ];\n\t\t\t\tif ( pass.enabled === false ) continue;\n\t\t\t\tpass.renderToScreen = this.renderToScreen && this.isLastEnabledPass( i );\n\t\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil; //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime ); //context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.swapBuffers();\n\n\t\t\t\t}\n\n\t\t\t\tif ( THREE.MaskPass !== undefined ) {\n\n\t\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t\t}\n\n\t\treset( renderTarget ) {\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\tconst size = this.renderer.getSize( new THREE.Vector2() );\n\t\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\t\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t\t}\n\n\t\t\tthis.renderTarget1.dispose();\n\t\t\tthis.renderTarget2.dispose();\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t}\n\n\t\tsetSize( width, height ) {\n\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\t\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetPixelRatio( pixelRatio ) {\n\n\t\t\tthis._pixelRatio = pixelRatio;\n\t\t\tthis.setSize( this._width, this._height );\n\n\t\t}\n\n\t}\n\n\tclass Pass {\n\n\t\tconstructor() {\n\n\t\t\t// if set to true, the pass is processed by the composer\n\t\t\tthis.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering\n\n\t\t\tthis.needsSwap = true; // if set to true, the pass clears its buffer before rendering\n\n\t\t\tthis.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\n\t\t\tthis.renderToScreen = false;\n\n\t\t}\n\n\t\tsetSize() {}\n\n\t\trender() {\n\n\t\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t\t}\n\n\t} // Helper for passes that need to fill the viewport with a single quad.\n\n\n\tconst _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 ); // https://github.com/mrdoob/three.js/pull/21358\n\n\n\tconst _geometry = new THREE.BufferGeometry();\n\n\t_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\n\t_geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\tclass FullScreenQuad {\n\n\t\tconstructor( material ) {\n\n\t\t\tthis._mesh = new THREE.Mesh( _geometry, material );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis._mesh.geometry.dispose();\n\n\t\t}\n\n\t\trender( renderer ) {\n\n\t\t\trenderer.render( this._mesh, _camera );\n\n\t\t}\n\n\t\tget material() {\n\n\t\t\treturn this._mesh.material;\n\n\t\t}\n\n\t\tset material( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t}\n\n\tTHREE.EffectComposer = EffectComposer;\n\tTHREE.FullScreenQuad = FullScreenQuad;\n\tTHREE.Pass = Pass;\n\n} )();\n"]}